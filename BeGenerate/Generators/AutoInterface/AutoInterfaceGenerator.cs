using System;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using BeGenerate.AutoInterface;
using BeGenerate.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace BeGenerate.Generators.AutoInterface;

/// <summary> Generates interfaces from classes marked with <see cref="AutoInterfaceAttribute" />. </summary>
[Generator]
public sealed class AutoInterfaceGenerator : IIncrementalGenerator
{
    private static readonly string AutoInterfaceAttributeFullName = typeof(AutoInterfaceAttribute).FullName!;

    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context)
    {
        var infos = context.SyntaxProvider.ForAttributeWithMetadataName(
            AutoInterfaceAttributeFullName,
            (node, _) => node is ClassDeclarationSyntax,
            Emit);

        context.RegisterSourceOutput(
            infos,
            static (context, data) => context.AddSource(data.Filename, SourceText.From(data.Code, Encoding.UTF8)));
    }

    private static SourceFile Emit(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var node = (ClassDeclarationSyntax) context.TargetNode;
        var model = context.SemanticModel;
        var symbol = (INamedTypeSymbol) context.TargetSymbol;

        var autoInterfaceAttribute = symbol.GetAttributeInstances<AutoInterfaceAttribute>()
            .FirstOrDefault();
        Debug.Assert(autoInterfaceAttribute is not null);

        var code = new CodeBuilder();

        code.AddAutoGeneratedComment();
        code.Line();

        code.Line(
            model.GetNullableContext(node.SpanStart) switch
            {
                NullableContext.Disabled => "#nullable disable",
                _ => "#nullable enable"
            });
        code.Line();

        node.Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .SelectMany(s => s.Usings)
            .Concat((node.SyntaxTree.GetRoot(cancellationToken) as CompilationUnitSyntax)?.Usings ?? [])
            .Distinct()
            .Select(x => x.ToString())
            .Order()
            .ForEach(code.Line);
        code.Line();

        if (symbol.ContainingNamespace is not null)
            code.Line("namespace ", symbol.ContainingNamespace.ToDisplayString(), ";");
        code.Line();

        code.Line(GetDocumentation(node));
        code.AnnotateGeneratedCode();
        var interfaceName = autoInterfaceAttribute.Name ?? $"I{symbol.Name}";
        switch (autoInterfaceAttribute.Accessibility)
        {
            case InterfaceAccessibility.Public:
                code.Append("public ");
                break;
            case InterfaceAccessibility.Internal:
                code.Append("internal ");
                break;
            case InterfaceAccessibility.None:
                break;
            default:
                Debug.Fail($"Unknown accessibility {autoInterfaceAttribute.Accessibility}");
                break;
        }

        code.Append("partial interface ", interfaceName, node.TypeParameterList);

        var inherits = symbol.GetAttributes()
            .Where(
                a => a.AttributeClass is not null &&
                     a.AttributeClass.IsGenericType &&
                     a.AttributeClass.Name == nameof(ImplementsAttribute<object>))
            .SelectMany(a => a.AttributeClass!.TypeArguments)
            .ToArray();

        if (inherits.Any())
        {
            code.Append(": ");
            code.Join(", ", inherits.Select(x => x.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)));
        }

        if (node.ConstraintClauses.Any())
            code.Append(" ", node.ConstraintClauses);

        code.Line();
        code.Block(
            () => {
                node.Members.OfType<PropertyDeclarationSyntax>()
                    .Select(x => (Node: x, Symbol: model.GetDeclaredSymbol(x)!))
                    .Where(x => !x.Symbol.HasAttribute<ExcludeFromInterfaceAttribute>())
                    .Where(
                        x => x.Symbol.DeclaredAccessibility == Accessibility.Public ||
                             x.Node.ExplicitInterfaceSpecifier?.Name.ToString() == interfaceName)
                    .ForEach(
                        x => {
                            code.Line(GetDocumentation(x.Node));
                            code.Line(x.Node.AttributeLists);
                            code.Append(x.Node.Type, " ", x.Node.Identifier.Text);
                            code.Append(" {");

                            if (x.Symbol.GetMethod is not null &&
                                !x.Symbol.GetMethod.HasAttribute<ExcludeFromInterfaceAttribute>())
                            {
                                x.Node.AccessorList?.Accessors.Where(a => a.IsKind(SyntaxKind.GetAccessorDeclaration))
                                    .Select(a => a.AttributeLists)
                                    .Where(a => a.Any())
                                    .ForEach(a => code.Append(" ", a));
                                code.Append(" get;");
                            }

                            if (x.Symbol.SetMethod is not null &&
                                !x.Symbol.SetMethod.HasAttribute<ExcludeFromInterfaceAttribute>())
                            {
                                x.Node.AccessorList?.Accessors.Where(a => a.IsKind(SyntaxKind.SetAccessorDeclaration))
                                    .Select(a => a.AttributeLists)
                                    .Where(a => a.Any())
                                    .ForEach(a => code.Append(" ", a));
                                code.Append(" set;");
                            }

                            code.Line(" }");
                        });

                node.Members.OfType<MethodDeclarationSyntax>()
                    .Select(x => (Node: x, Symbol: model.GetDeclaredSymbol(x)!))
                    .Where(x => !x.Symbol.HasAttribute<ExcludeFromInterfaceAttribute>())
                    .Where(
                        x => x.Symbol.DeclaredAccessibility == Accessibility.Public ||
                             x.Node.ExplicitInterfaceSpecifier?.Name.ToString() == interfaceName)
                    .ForEach(
                        x => {
                            code.Line(GetDocumentation(x.Node));
                            code.Line(x.Node.AttributeLists);
                            code.Append(x.Node.ReturnType, " ", x.Node.Identifier.Text);
                            code.Append(x.Node.TypeParameterList);
                            code.Append("(");
                            code.Join(", ", x.Node.ParameterList.Parameters);
                            code.Append(")");
                            x.Node.ConstraintClauses.ForEach(
                                x1 => {
                                    code.Append(" ");
                                    code.Append(x1);
                                });
                            code.Line(";");
                        });
            });

        return new SourceFile
        {
            Filename = $"{symbol.ContainingNamespace?.ToDisplayString()}.{interfaceName}.g.cs",
            Code = code.ToString()
        };
    }

    private static string? GetDocumentation(CSharpSyntaxNode node)
    {
        var leadingTrivia = node.GetLeadingTrivia();
        var xmlDocs = leadingTrivia.Select(trivia => trivia.GetStructure())
            .OfType<DocumentationCommentTriviaSyntax>()
            .FirstOrDefault();

        // If found, return the string value of the XML
        if (xmlDocs is null)
            return null;

        var docs = xmlDocs.ToFullString();
        var lines = docs.Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries)
            .Select(x => x.Trim());
        var cleaned = string.Join('\n', lines);

        return cleaned;
    }
}
