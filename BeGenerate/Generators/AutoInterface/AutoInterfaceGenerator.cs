using System.Diagnostics;
using System.Linq;
using System.Text;
using BeGenerate.AutoInterface;
using BeGenerate.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace BeGenerate.Generators.AutoInterface;

/// <summary> Generates interfaces from classes marked with <see cref="AutoInterfaceAttribute" />. </summary>
[Generator]
public sealed class AutoInterfaceGenerator : IIncrementalGenerator
{
    private static readonly string AutoInterfaceAttributeFullName = typeof(AutoInterfaceAttribute).FullName!;

    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context)
    {
        var infos = context.SyntaxProvider.ForAttributeWithMetadataName(
            AutoInterfaceAttributeFullName,
            (node, _) => node is ClassDeclarationSyntax,
            static (ctx, _) => new AutoInterfaceFileEmitter(ctx).Emit());

        context.RegisterSourceOutput(
            infos,
            static (context, data) => { context.AddSource(data.Filename, SourceText.From(data.Code, Encoding.UTF8)); });
    }
}

internal sealed record SourceFile
{
    public required string Code { get; init; }
    public required string Filename { get; init; }
}

internal sealed class AutoInterfaceFileEmitter
{
    private readonly SemanticModel _model;
    private readonly ClassDeclarationSyntax _node;
    private readonly CodeBuilder _out = new();
    private readonly INamedTypeSymbol _symbol;

    public AutoInterfaceFileEmitter(GeneratorAttributeSyntaxContext context)
    {
        _symbol = (INamedTypeSymbol) context.TargetSymbol;
        _node = (ClassDeclarationSyntax) context.TargetNode;
        _model = context.SemanticModel;

        Debug.Assert(_symbol.HasAttribute<AutoInterfaceAttribute>());
    }

    public SourceFile Emit()
    {
        EmitGeneratedCodeHeader();
        EmitNullability();
        EmitUsings();
        EmitNamespaceDeclaration();
        EmitInterfaceDeclaration();

        return new SourceFile
        {
            Filename = $"{_symbol.ContainingNamespace?.ToDisplayString()}.I{_symbol.Name}.g.cs",
            Code = _out.ToString()
        };
    }

    private void EmitGeneratedCodeHeader()
    {
        _out.Line("// <auto-generated>")
            .Line("// This code was generated by a tool.")
            .Line("// </auto-generated>");
    }

    private void EmitInterfaceDeclaration()
    {
        _out.EnsureEmptyLine()
            .AnnotateGeneratedCode()
            .Append($"public partial interface I{_symbol.Name}")
            .Append(_node.TypeParameterList?.ToString())
            .Append(" ")
            .Append(_node.ConstraintClauses.ToString())
            .Line()
            .Block(_ => { EmitMembers(); });
    }

    private void EmitMembers()
    {
        foreach (var propertyNode in _node.Members.OfType<PropertyDeclarationSyntax>())
        {
            var propertySymbol = ModelExtensions.GetDeclaredSymbol(_model, propertyNode) as IPropertySymbol;
            Debug.Assert(propertySymbol is not null);
            EmitProperty(propertyNode, propertySymbol);
        }

        foreach (var methodNode in _node.Members.OfType<MethodDeclarationSyntax>())
        {
            var methodSymbol = ModelExtensions.GetDeclaredSymbol(_model, methodNode) as IMethodSymbol;
            Debug.Assert(methodSymbol is not null);
            EmitMethod(methodNode, methodSymbol);
        }
    }

    private void EmitMethod(MethodDeclarationSyntax node, IMethodSymbol symbol)
    {
        if (symbol.HasAttribute<ExcludeFromInterfaceAttribute>())
            return;

        // TODO Explicit declaration
        if (symbol.DeclaredAccessibility != Accessibility.Public)
            return;

        _out.Lines(node.AttributeLists.Select(p => p.ToString()))
            .Append($"{node.ReturnType.ToString()} {node.Identifier.Text}")
            .Append(node.TypeParameterList?.ToString())
            .Parens(node.ParameterList.Parameters.Select(p => p.ToString()))
            .Join(" ", node.ConstraintClauses.Select(p => $" {p.ToString()}"))
            .Line(";");
    }

    private void EmitNamespaceDeclaration()
    {
        if (_symbol.ContainingNamespace is not null)
        {
            _out.EnsureEmptyLine()
                .Line($"namespace {_symbol.ContainingNamespace.ToDisplayString()};")
                .Line();
        }
    }

    private void EmitNullability()
    {
        var isNullabilityEnabled = _model.GetNullableContext(_node.SpanStart) != NullableContext.Disabled;
        _out.EnsureEmptyLine()
            .Directive("nullable", isNullabilityEnabled ? "enable" : "disable");
    }

    private void EmitProperty(PropertyDeclarationSyntax node, IPropertySymbol symbol)
    {
        if (symbol.HasAttribute<ExcludeFromInterfaceAttribute>())
            return;

        // TODO Explicit declaration
        if (symbol.DeclaredAccessibility != Accessibility.Public)
            return;

        _out.Lines(node.AttributeLists.Select(p => p.ToString()))
            .Append($"{node.Type.ToString()} {node.Identifier.Text}")
            .Append(" {");

        if (!symbol.GetMethod.HasAttribute<ExcludeFromInterfaceAttribute>())
        {
            var getAccessor =
                node.AccessorList?.Accessors.FirstOrDefault(a => a.IsKind(SyntaxKind.GetAccessorDeclaration));
            if (getAccessor is not null)
            {
                _out.Append(" ")
                    .Join(" ", [..getAccessor.AttributeLists.Select(m => m.ToString()), "get;"]);
            }
        }

        if (!symbol.SetMethod.HasAttribute<ExcludeFromInterfaceAttribute>())
        {
            var setAccessor =
                node.AccessorList?.Accessors.FirstOrDefault(a => a.IsKind(SyntaxKind.SetAccessorDeclaration));
            if (setAccessor is not null)
            {
                _out.Append(" ")
                    .Join(" ", [..setAccessor.AttributeLists.Select(m => m.ToString()), "set;"]);
            }
        }

        _out.Line(" }");
    }

    private void EmitUsings()
    {
        _out.EnsureEmptyLine()
            .Lines(
                _node.Ancestors()
                    .OfType<NamespaceDeclarationSyntax>()
                    .SelectMany(s => s.Usings)
                    .Concat((_node.SyntaxTree.GetRoot() as CompilationUnitSyntax)?.Usings ?? [])
                    .Select(u => u.ToString())
                    .Distinct()
                    .Order());
    }
}
