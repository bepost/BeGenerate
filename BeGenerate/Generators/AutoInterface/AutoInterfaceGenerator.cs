using System.Diagnostics;
using System.Linq;
using System.Text;
using BeGenerate.AutoInterface;
using BeGenerate.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace BeGenerate.Generators.AutoInterface;

/// <summary> Generates interfaces from classes marked with <see cref="AutoInterfaceAttribute" />. </summary>
[Generator]
public sealed class AutoInterfaceGenerator : IIncrementalGenerator
{
    private static readonly string AutoInterfaceAttributeFullName = typeof(AutoInterfaceAttribute).FullName!;

    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context)
    {
        var infos = context.SyntaxProvider.ForAttributeWithMetadataName(
            AutoInterfaceAttributeFullName,
            (node, _) => node is ClassDeclarationSyntax,
            static (ctx, _) => new AutoInterfaceFileEmitter(ctx).Emit());

        context.RegisterSourceOutput(
            infos,
            static (context, data) => { context.AddSource(data.Filename, SourceText.From(data.Code, Encoding.UTF8)); });
    }
}

internal sealed record SourceFile
{
    public required string Code { get; init; }
    public required string Filename { get; init; }
}

internal sealed class AutoInterfaceFileEmitter
{
    private readonly SemanticModel _model;
    private readonly ClassDeclarationSyntax _node;
    private readonly INamedTypeSymbol _symbol;

    public AutoInterfaceFileEmitter(GeneratorAttributeSyntaxContext context)
    {
        _node = (ClassDeclarationSyntax) context.TargetNode;
        _model = context.SemanticModel;
        _symbol = (INamedTypeSymbol) context.TargetSymbol;
    }

    public SourceFile Emit()
    {
        var code = new CodeBuilder();

        code.AddAutoGeneratedComment();
        code.Line();
        code.Line(
            _model.GetNullableContext(_node.SpanStart) switch
            {
                NullableContext.Disabled => "#nullable disable",
                _ => "#nullable enable"
            });
        code.Line();
        _node.Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .SelectMany(s => s.Usings)
            .Concat((_node.SyntaxTree.GetRoot() as CompilationUnitSyntax)?.Usings ?? [])
            .Distinct()
            .Select(x => x.ToString())
            .Order()
            .ForEach(code.Line);
        code.Line();
        if (_symbol.ContainingNamespace is not null)
            code.Line("namespace ", _symbol.ContainingNamespace.ToDisplayString(), ";");
        code.Line();
        EmitInterfaceDeclaration(code);

        return new SourceFile
        {
            Filename = $"{_symbol.ContainingNamespace?.ToDisplayString()}.I{_symbol.Name}.g.cs",
            Code = code.ToString()
        };
    }

    private void EmitInterfaceDeclaration(CodeBuilder code)
    {
        code.Line();
        code.AnnotateGeneratedCode();
        code.Line(
            "public partial interface ",
            $"I{_symbol.Name}",
            _node.TypeParameterList,
            " ",
            _node.ConstraintClauses);
        code.Block(() => { EmitMembers(code); });
    }

    private void EmitMembers(CodeBuilder code)
    {
        foreach (var propertyNode in _node.Members.OfType<PropertyDeclarationSyntax>())
        {
            var propertySymbol = ModelExtensions.GetDeclaredSymbol(_model, propertyNode) as IPropertySymbol;
            Debug.Assert(propertySymbol is not null);
            EmitProperty(code, propertyNode, propertySymbol);
        }

        foreach (var methodNode in _node.Members.OfType<MethodDeclarationSyntax>())
        {
            var methodSymbol = ModelExtensions.GetDeclaredSymbol(_model, methodNode) as IMethodSymbol;
            Debug.Assert(methodSymbol is not null);
            EmitMethod(code, methodNode, methodSymbol);
        }
    }

    private void EmitMethod(CodeBuilder code, MethodDeclarationSyntax node, IMethodSymbol symbol)
    {
        if (symbol.HasAttribute<ExcludeFromInterfaceAttribute>())
            return;

        // TODO Explicit declaration
        if (symbol.DeclaredAccessibility != Accessibility.Public)
            return;
        node.AttributeLists.ForEach(code.Line);

        code.Append(node.ReturnType, " ", node.Identifier.Text);
        code.Append(node.TypeParameterList?.ToString());
        code.Append("(");
        code.Join(", ", node.ParameterList.Parameters);
        code.Append(")");
        node.ConstraintClauses.ForEach(
            x => {
                code.Append(" ");
                code.Append(x);
            });
        code.Line(";");
    }

    private void EmitProperty(CodeBuilder code, PropertyDeclarationSyntax node, IPropertySymbol symbol)
    {
        if (symbol.HasAttribute<ExcludeFromInterfaceAttribute>())
            return;

        // TODO Explicit declaration
        if (symbol.DeclaredAccessibility != Accessibility.Public)
            return;

        code.Line(node.AttributeLists);
        code.Append(node.Type, " ", node.Identifier.Text);
        code.Append(" {");

        if (!symbol.GetMethod.HasAttribute<ExcludeFromInterfaceAttribute>())
        {
            var getAccessor =
                node.AccessorList?.Accessors.FirstOrDefault(a => a.IsKind(SyntaxKind.GetAccessorDeclaration));
            if (getAccessor is not null)
            {
                foreach (var attributeList in getAccessor.AttributeLists)
                    code.Append(" ", attributeList);

                code.Append(" get;");
            }
        }

        if (!symbol.SetMethod.HasAttribute<ExcludeFromInterfaceAttribute>())
        {
            var setAccessor =
                node.AccessorList?.Accessors.FirstOrDefault(a => a.IsKind(SyntaxKind.SetAccessorDeclaration));
            if (setAccessor is not null)
            {
                foreach (var attributeList in setAccessor.AttributeLists)
                    code.Append(" ", attributeList);

                code.Append(" set;");
            }
        }

        code.Line(" }");
    }
}
