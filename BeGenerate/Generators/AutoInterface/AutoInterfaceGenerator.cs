using System.Linq;
using System.Text;
using System.Threading;
using BeGenerate.AutoInterface;
using BeGenerate.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace BeGenerate.Generators.AutoInterface;

/// <summary> Generates interfaces from classes marked with <see cref="AutoInterfaceAttribute" />. </summary>
[Generator]
public sealed class AutoInterfaceGenerator : IIncrementalGenerator
{
    private static readonly string AutoInterfaceAttributeFullName = typeof(AutoInterfaceAttribute).FullName!;

    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context)
    {
        var infos = context.SyntaxProvider.ForAttributeWithMetadataName(
            AutoInterfaceAttributeFullName,
            (node, _) => node is ClassDeclarationSyntax,
            Emit);

        context.RegisterSourceOutput(
            infos,
            static (context, data) => context.AddSource(data.Filename, SourceText.From(data.Code, Encoding.UTF8)));
    }

    private static SourceFile Emit(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var node = (ClassDeclarationSyntax) context.TargetNode;
        var model = context.SemanticModel;
        var symbol = (INamedTypeSymbol) context.TargetSymbol;

        var code = new CodeBuilder();

        code.AddAutoGeneratedComment();
        code.Line();

        code.Line(
            model.GetNullableContext(node.SpanStart) switch
            {
                NullableContext.Disabled => "#nullable disable",
                _ => "#nullable enable"
            });
        code.Line();

        node.Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .SelectMany(s => s.Usings)
            .Concat((node.SyntaxTree.GetRoot() as CompilationUnitSyntax)?.Usings ?? [])
            .Distinct()
            .Select(x => x.ToString())
            .Order()
            .ForEach(code.Line);
        code.Line();

        if (symbol.ContainingNamespace is not null)
            code.Line("namespace ", symbol.ContainingNamespace.ToDisplayString(), ";");
        code.Line();

        code.AnnotateGeneratedCode();
        code.Line("public partial interface ", $"I{symbol.Name}", node.TypeParameterList, " ", node.ConstraintClauses);
        code.Block(
            () => {
                node.Members.OfType<PropertyDeclarationSyntax>()
                    .Select(x => (Node: x, Symbol: (IPropertySymbol) ModelExtensions.GetDeclaredSymbol(model, x)!))
                    .Where(x => !x.Symbol.HasAttribute<ExcludeFromInterfaceAttribute>())
                    // TODO Explicit declarations
                    .Where(x => x.Symbol.DeclaredAccessibility == Accessibility.Public)
                    .ForEach(
                        x => {
                            code.Line(x.Node.AttributeLists);
                            code.Append(x.Node.Type, " ", x.Node.Identifier.Text);
                            code.Append(" {");

                            var getAccessor =
                                x.Node.AccessorList?.Accessors.FirstOrDefault(
                                    a => a.IsKind(SyntaxKind.GetAccessorDeclaration));
                            if (getAccessor is not null &&
                                !x.Symbol.GetMethod.HasAttribute<ExcludeFromInterfaceAttribute>())
                            {
                                foreach (var attributeList in getAccessor.AttributeLists)
                                    code.Append(" ", attributeList);
                                code.Append(" get;");
                            }

                            var setAccessor =
                                x.Node.AccessorList?.Accessors.FirstOrDefault(
                                    a => a.IsKind(SyntaxKind.SetAccessorDeclaration));
                            if (setAccessor is not null &&
                                !x.Symbol.SetMethod.HasAttribute<ExcludeFromInterfaceAttribute>())
                            {
                                foreach (var attributeList in setAccessor.AttributeLists)
                                    code.Append(" ", attributeList);
                                code.Append(" set;");
                            }

                            code.Line(" }");
                        });

                node.Members.OfType<MethodDeclarationSyntax>()
                    .Select(x => (Node: x, Symbol: (IMethodSymbol) ModelExtensions.GetDeclaredSymbol(model, x)!))
                    .Where(x => !x.Symbol.HasAttribute<ExcludeFromInterfaceAttribute>())
                    // TODO Explicit declarations
                    .Where(x => x.Symbol.DeclaredAccessibility == Accessibility.Public)
                    .ForEach(
                        x => {
                            x.Node.AttributeLists.ForEach(code.Line);

                            code.Append(x.Node.ReturnType, " ", x.Node.Identifier.Text);
                            code.Append(x.Node.TypeParameterList?.ToString());
                            code.Append("(");
                            code.Join(", ", x.Node.ParameterList.Parameters);
                            code.Append(")");
                            x.Node.ConstraintClauses.ForEach(
                                x1 => {
                                    code.Append(" ");
                                    code.Append(x1);
                                });
                            code.Line(";");
                        });
            });

        return new SourceFile
        {
            Filename = $"{symbol.ContainingNamespace?.ToDisplayString()}.I{symbol.Name}.g.cs",
            Code = code.ToString()
        };
    }
}
